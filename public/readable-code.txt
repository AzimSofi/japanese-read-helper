< 1章
理解しやすいコード
>> 第1章：コードを理解しやすくする方法を解説します。

< この5年間で「ひどいコード」をたくさん集めてきた（その多くは自分たちのものだけど）。そして、なぜそのコードがひどいのか、それを改善するにはどんな原則や技法が使えるのかを調べてみた。そこからわかったのは、すべての原則はたった1つのテーマから生じているということだ。
>> 過去5年間で集めた「ひどいコード」を分析した結果、コード改善のすべての原則は一つのテーマに基づいていることが分かりました。

< [Tip]
鍵となる考え
>> 【ヒント】重要な考え方

< コードは理解しやすくなければいけない。
>> コードは誰にでも理解できるものでなければなりません。

< これがコードを書く上でいちばん大切な原則だ。これからこの原則を日々のコーディングのさまざまな場面に当てはめる方法を紹介していきたいと思う。でもその前に、この原則のことをもっと詳しく説明しよう。どうしてこの原則がそんなに大切なんだろうか。
>> これはコーディングで最も大切な原則であり、これから様々な場面での適用方法を説明しますが、その前にこの原則の重要性を説明します。

< 1.1　「優れた」コードって何？
>> 1.1 「優れた」コードとは何か？

< プログラマというのは（ぼくたちもそうだけど）、何となく直感でプログラミングのことを決めていることが多い。例えば、このようなコードのほうが、
>> プログラマは直感で、あるコードが他のコードより優れていると判断することがよくあります。

< for (Node* node = list-head; node != NULL; node = node->next)
    Print(node->data);
以下のコードよりも優れているとみんな思っている。
>> 例えば、この一行のコードは、次の複数の行のコードよりも良いと考えられています。

< Node* node = list->head;
if (node == NULL) return;

while (node->next != NULL) {
    Print(node->data);
    node = node->next;
}
if (node != NULL) Print(node->data);
（どちらも動作は全く同じなのに）
>> （動作は同じでも）上記のような複数行のコードよりも優れていると一般に思われています。

< でも、どちらが優れているかわからないことも多い。例えば、このようなコードは、
>> しかし、どちらが優れているか判断が難しいケースもあります。例えば、次のコードは、

< return exponent >= 0 ? mantissa * (1 << exponent) : mantissa / (1 << -exponent);
以下のコードよりも優れているのだろうか。
>> 下のコードよりも優れているでしょうか？

< if (exponent >= 0) {
    return mantissa * (1 << exponent);
} else {
    return mantissa / (1 << -exponent);
}
前者のほうが簡潔だ。でも、後者のほうが安心できる。「簡潔」と「安心」はどちらが大切なことなんだろう？　君ならどうやって決めるだろうか？
>> 前者は簡潔ですが、後者はより安全に感じられます。「簡潔さ」と「安心感」のどちらを優先するか、どう決めるべきでしょうか？

< 1.2　読みやすさの基本定理
>> 1.2 読みやすさの基本定理

< さっき見たようなコードをたくさん調査してみたら、読みやすさの基準となるものにたどり着くことができた。これはどんな基準よりも大切なものなんだ。すごく大切なので「読みやすさの基本定理」と呼ぶことにしよう。
>> 多くのコードを調査した結果、最も重要で「読みやすさの基本定理」と呼ぶべき基準を発見しました。

< [Tip]
鍵となる考え
>> 【ヒント】重要な考え方

< コードは他の人が最短時間で理解できるように書かなければいけない。
>> コードは、他の人が最も短時間で理解できるように書く必要があります。

< これってどういう意味だと思う？　そのまんまの意味だ。例えば、同僚にコードを読んでもらって、彼が理解するまでにかかる時間を計測するとしよう。この「理解するまでにかかる時間」という数値を最短にするってことだ。
>> これは、同僚がコードを読んで完全に理解するまでにかかる時間を最短にする、という意味です。

< それから「理解する」っていう言葉には、高いハードルを設けてある。「コードを理解する」というのは、変更を加えたりバグを見つけたりできるという意味だ。他のコードと連携する方法も理解しておかなければいけない。
>> ここでいう「理解する」とは、コードの変更やバグの発見、他のコードとの連携方法もわかるレベルを指します。

< もしかすると、こんなふうに考えているかもしれないね。「他の人が理解できるって、誰が得するんだよ？　このコードを使ってるのはオレだけなんだぞ！」　でもね、たとえ君ひとりのプロジェクトだったとしても、この目標には取り組むだけの価値があるんだ。「他の人」というのは、自分のコードに見覚えのない6か月後の「君自身」かもしれない。君のプロジェクトに途中から誰かが参加しないとも言い切れない。「使い捨てのコード」が他のプロジェクトで再利用される可能性だってある。
>> 「自分しか使わないコードをなぜ他人にも理解できるように書くのか」と思うかもしれませんが、それは6ヶ月後の「あなた自身」や、後から参加するメンバー、再利用される可能性のあるコードのためにも重要です。

< 1.3　小さなことは絶対にいいこと？
>> 1.3 コードは短ければ良いのか？

< 問題を解決するコードは短いほうがいい（13章「短いコードを書く」参照）。2,000行のクラスのほうが5,000行のクラスよりも理解するまでにかかる時間は短いはずだ。
>> コードは短い方が問題を解決しやすいです（例：2000行のクラスは5000行より早く理解できる）。

< でも、短ければいいってもんじゃない！　このような1行のコードは、
>> しかし、短すぎるのも問題です。例えば、次の1行のコードは、

< assert((!(bucket = FindBucket(key))) || !bucket->IsOccupied());
以下のような2行のコードを理解するよりも時間がかかることが多い。
>> 次の2行のコードよりも理解に時間がかかることが多いです。

< bucket = FindBucket(key);
if (bucket != NULL) assert(!bucket->IsOccupied());
コメントをつけると「コードが長く」なるけど、そのほうが理解しやすいこともある。
>> コメントでコードが長くなっても、理解しやすくなる場合があります。

< // "hash = (65599 * hash) + c" の高速版
hash = (hash << 6) + (hash << 16) - hash + c;
コードは短くしたほうがいい。だけど、「理解するまでにかかる時間」を短くするほうが大切だ。
>> コードは短縮すべきですが、それよりも「理解するまでにかかる時間」を短縮することのほうが重要です。

< 1.4　「理解するまでにかかる時間」は競合する？
>> 1.4 「理解するまでにかかる時間」は他の目標と矛盾するか？

< 「それじゃあ、その他の条件は？　コードを効率化するとか、設計をうまくやるとか、テストしやすいとか、いろいろあるじゃん？　そういうのは理解しやすさと競合しないわけ？」　そんなことを考えるかもしれないね。
>> 「コード効率化、設計、テストのしやすさなど、他の目標は理解しやすさと矛盾しないのか？」と疑問に思うかもしれません。

< でも、その他の目標とは全く競合しないんだ。高度に最適化されたコードであっても、もっと理解しやすくできるはずだ。それに、理解しやすいコードというのは、優れた設計やテストのしやすさにつながることが多い。
>> 実は、他の目標と理解しやすさは競合しません。最適化されたコードでも理解しやすくでき、理解しやすいコードは優れた設計やテストのしやすさにつながります。

< 本書では、いろんな状況に「読みやすさ」を当てはめる方法を紹介している。どうすればいいかわからなくなったときは、本書で紹介する規則や原則よりも「読みやすさの基本定理」を最優先に考えて欲しい。コードを見たらすぐにリファクタリングしたくなるプログラマもいるだろうけど、常に一歩下がって「このコードは理解しやすいだろうか？」と自問自答してみることが大切だ。理解しやすいコードになってから、次のコードを書き始めてもいいんじゃないかな。
>> 本書の規則より「読みやすさの基本定理」を最優先にし、リファクタリングする前に「このコードは理解しやすいか？」と常に自問することが大切です。

< 1.5　でもやるんだよ
>> 1.5 実行しよう

< 想像上の誰かが自分のコードを理解しやすいかなんて考えるのは大変なことだ。これまでとは違う脳ミソを回転させなきゃいけない。
>> 他の誰かにとってコードが理解しやすいかを考えるのは大変で、新しい考え方が必要です。

< でも、この目標を（ぼくたちみたいに）受け入れたら、君はきっと優秀なプログラマになれるはずだ。自分の仕事に誇りを持ち、周囲のみんなが喜んで使ってくれるような、バグの少ないコードを作り出せるようになる。さあ、始めよう！
>> この目標を受け入れることで、あなたは優秀なプログラマになり、誇りを持てるバグの少ないコードを生み出せるでしょう。さあ、始めましょう！

< 第I部
表面上の改善
>> 第I部：コードの表面的な改善

< 読みやすさの旅の始まりは「表面上」の改善だ。適切に名前を選んだり、優れたコメントを書いたり、コードをキレイにフォーマットしたり。こうした変更は簡単にできる。プログラムの変更やリファクタリングをしなくても「入れ替え」可能だ。それに、時間をかけずに少しずつ変更することもできる。
>> 読みやすさの最初のステップは、名前、コメント、フォーマットといった「表面的な」改善で、これらはプログラムのロジックを変えずに簡単かつ少しずつ実施できます。

< このテーマはすごく大切だ。コードのすべての行に影響するからね。個々の変更は小さいかもしれないけど、それらを合わせれば、コードに大きな改善をもたらせる。コードに適切な名前をつければ、優れたコメントを書けば、空白の使い方をキレイにすれば、コードはもっと読みやすくなる。
>> このテーマは全てのコード行に影響し、小さな改善でも全体として大きな読みやすさの向上をもたらします。

< 読みやすさを改善する方法は「表面下」にもたくさんある（それらについてはあとで説明する）。でも、「表面上」の改善は手間のかからない割に幅広く適用できるものなので、最初に触れておくのがいいだろう。
>> 読みやすさの改善には「表面下」の方法もありますが、手軽で適用範囲の広い「表面上の」改善から説明します。

< 2章
名前に情報を詰め込む
>> 第2章：名前に多くの情報を含める

< 名前をつけるときには、それが変数であっても、関数であっても、クラスであっても、同じ原則を当てはめることができる。名前は短いコメントだと思えばいい。短くてもいい名前をつければ、それだけ多くの情報を伝えることができる。
>> 変数、関数、クラスの名付けには同じ原則が適用され、名前を短いコメントと見なすことで多くの情報を伝えられます。

< [Tip]
鍵となる考え
>> 【ヒント】重要な考え方

< 名前に情報を詰め込む。
>> 名前に必要な情報を凝縮させましょう。

< プログラムに使われる名前というのはハッキリしないものが多い。例えば、tmpなんかがそうだ。でも、sizeやgetみたいに一見すると問題がなさそうな名前であっても、情報が含まれていないことがある。
>> プログラムの名前には「tmp」のような不明確なものや、「size」や「get」のように一見問題なくても情報が不足しているものがあります。

< これから情報を詰め込んだ名前のつけ方を紹介する。本章は、以下の6つのテーマで構成されている。
>> これから情報を詰め込んだ名前のつけ方を、以下の6つのテーマで紹介します。

< 明確な単語を選ぶ
汎用的な名前を避ける（あるいは、使う状況を選ぶ）
抽象的な名前よりも具体的な名前を使う
接尾辞や接頭辞を使って情報を追加する
名前の長さを決める
名前のフォーマットで情報を伝える
>> 1. 明確な単語を選ぶ。2. 汎用的な名前を避ける（または使う状況を限定する）。3. 抽象的な名前より具体的な名前を使う。4. 接尾辞や接頭辞で情報を加える。5. 名前の長さを適切に決める。6. フォーマットで情報を伝える。

< 2.1　明確な単語を選ぶ
>> 2.1 明確な単語を選ぶ

< 「名前に情報を詰め込む」には、明確な単語を選ばなければいけない。「空虚な」単語は避けるべきだ。
>> 名前に情報を込めるためには、明確な単語を選び、「意味のない」単語を避けるべきです。

< 例えば、「get」はあまり明確な単語ではない。
>> 例えば、「get」はあまり明確ではありません。

< def GetPage(url):
    ...
「get」という単語からは何も伝わってこない。このメソッドはページをどこから取ってくるのだろう？　ローカルキャッシュから？　データベースから？　インターネットから？　インターネットから取ってくるのであれば、FetchPage()やDownloadPage()のほうが明確だ。
>> 「GetPage(url)」の「get」は情報が少なく、ページの取得元（キャッシュ、DB、インターネットなど）が不明です。インターネットからならFetchPage()などが明確です。

< 次は、BinaryTreeクラスの例だ。
>> 次はBinaryTreeクラスの例です。

< class BinaryTree {
    int Size();
    ...
};
このSize()メソッドは何を返すのだろうか？　ツリーの高さ？　ノードの数？　ツリーのメモリ消費量？　Size()では何も情報が伝わらない。目的に適した明確な名前をつけるなら、それぞれHeight()・NumNodes()・MemoryBytes()になるだろう。
>> Size()メソッドは「高さ」「ノード数」「メモリ量」のどれを返すか不明確です。目的に応じてHeight()、NumNodes()、MemoryBytes()など明確な名前をつけるべきです。

< もう1つの例は、とあるThreadクラスだ。
>> もう一つの例はThreadクラスです。

< class Thread {
    void Stop();
    ...
};
Stop()という名前でもいいけど、動作に合わせてもっと明確な名前をつけたほうがいいと思う。例えば、取り消しができない重い操作なら、Kill()にするといい。あとからResume()できるなら、Pause()にしてもいいかもしれない。
>> Stop()よりも、動作に合わせてKill()（取り消し不可な操作の場合）やPause()（再開可能な場合）など、より明確な名前をつけるべきです。

< もっと「カラフル」な単語を探す
>> より「表現力豊かな」単語を探す

< シソーラス（類語辞典）を使って調べよう。友達にもっといい名前がないかと聞いてみよう。英語は豊かな言語だから、選べる単語はたくさんあるはずだ。
>> 類語辞典を使ったり友人に聞いたりして、より良い単語を探しましょう。

< 例として、いくつかの単語と状況に合わせて使えるもっと「カラフル」なバージョンの単語を紹介しておこう。
>> 状況に応じて使える、より表現力豊かな単語の例を紹介します。

< 単語	代替案
send	deliver, dispatch, announce, distribute, route
find	search, extract, locate, recover
start	launch, create, begin, open
make	create, set up, build, generate, compose, add, new
>> （省略：単語とその代替案のリスト）

< ただし、やりすぎはいけない。PHPには、文字列をexplode()する関数がある。カラフルな名前だし、何かを分割する様子がうまく表現できている。だけど、split()と何が違うんだろう？（2つの関数は別物だけど、名前からその違いはわからない）
>> ただし、凝りすぎるのは禁物です。PHPのexplode()のように表現力豊かな名前でも、split()と機能の違いが名前からわからない例もあります（実際には別機能）。

< [Tip]
鍵となる考え
>> 【ヒント】重要な考え方

< 気取った言い回しよりも明確で正確なほうがいい。
>> よりも明確で正確な表現を選びましょう。

< 2.2　tmpやretvalなどの汎用的な名前を避ける
>> 2.2 tmpやretvalなどの汎用的な名前を避ける

< tmp・retval・fooのような名前をつけるのは、「名前のことなんて考えていません」と言っているようなものだ。このような「空虚な名前」をつけるのではなく、エンティティの値や目的を表した名前を選ぼう。
>> tmpやretvalのような名前は「名付けを考えていない」ことを示しており、代わりに値や目的を表す名前を選びましょう。

< 例えば、retvalを使っているJavaScriptの関数があるとする。
>> 例えば、retvalを使っているJavaScript関数を考えます。

< var euclidean_norm = function (v) {
    var retval = 0.0;
    for (var i = 0; i < v.length; i += 1)
        retval += v[i] * v[i];
    return Math.sqrt(retval);
};
いい名前が思いつかなかったら、戻り値にretvalとつけたくなる。でも、retvalには「これは戻り値です」以外の情報はない（戻り値なのは当たり前だ）。
>> 良い名前が思いつかないとretvalを使いがちですが、これには「戻り値である」という当たり前の情報しか含まれていません。

< いい名前というのは、変数の目的や値を表すものだ。ここでは、vの2乗の合計を表しているわけだから、sum_squaresという名前がいいだろう。こうしておけば、変数の目的を事前に伝えることができるし、バグの発見にも役立つはずだ。
>> 良い名前は変数の目的や値を表すべきで、この例ではsum_squaresが適切です。これにより変数の目的が明確になり、バグ発見にも役立ちます。

< 例えば、ループ内の処理を間違えて以下のように書いたとする。
>> 例えば、ループ内で以下のように間違った処理を書いたとします。

< retval += v[i];
変数名がsum_squaresだったら、バグを見つけやすい。
>> 変数名がsum_squaresなら、バグを見つけやすくなります。

< sum_squares += v[i];  // 合計する「square（2乗）」がない。バグだ！
[Tip]
アドバイス
>> （省略：バグ発見の例）

< retvalという名前には情報がない。変数の値を表すような名前を使おう。
>> 【ヒント】retvalには情報がないため、変数の値を表す名前を使いましょう。

< ただし、汎用的な名前に意味がないわけではない。汎用的な名前をうまく使った例を見ていこう。
>> ただし、汎用的な名前も使いどころによっては有用です。例を見ていきましょう。

< tmp
2つの変数を入れ替える古典的な例を考えてみよう。
>> tmp：2つの変数を入れ替える例を考えます。

< if (right < left) {
    tmp = right;
    right = left;
    left = tmp;
}
このような場合は、tmpという名前で全く問題ない。この変数の目的は、情報の一時的な保管だ。しかも、生存期間はわずか数行である。tmpという名前で「この変数には他に役割がない」という明確な意味を伝えている。つまり、他の関数に渡されたり、何度も書き換えられたりしない、ということだ。
>> この場合、tmpは一時保管という目的が明確で、生存期間も短いため問題ありません。これにより、他の用途がないことが伝わります。

< でも、以下のtmpは単なる怠慢だ。
>> しかし、次のtmpの使用例は単なる怠惰です。

< String tmp = user.name();
tmp += " " + user.phone_number();
tmp += " " + user.email();
...
template.set("user_info", tmp);
生存期間は短いけど、この変数にとっていちばん大切なことは「一時的な保管」ではない。これをわかりやすくするには、user_infoのような名前に変えるといいだろう。
>> この変数の一番大切な目的は一時保管ではないため、user_infoのような名前に変えて目的を明確にすべきです。

< 以下の例では、名前の一部にtmpを使っている。
>> 以下の例では、名前の一部にtmpを使用しています。

< tmp_file = tempfile.NamedTemporaryFile()
...
SaveData(tmp_file, ...)
ファイルオブジェクトなので、ただのtmpではなくtmp_fileという名前になっている。これをtmpにしていたら、どうなっていただろうか。
>> これはファイルオブジェクトなのでtmp_fileという名前ですが、もしtmpだったらどうなるでしょうか。

< SaveData(tmp, ...)
この行だけを見ると、tmpがファイルなのか、ファイル名なのか、データなのかがわからない。
>> この行だけでは、tmpがファイルか、ファイル名か、データか不明確になります。

< [Tip]
アドバイス
>> 【ヒント】アドバイス

< tmpという名前は、生存期間が短くて、一時的な保管が最も大切な変数にだけ使おう。
>> tmpは、生存期間が短く、一時保管が主な目的の変数にのみ使いましょう。

< ループイテレータ
i・j・k・iterなどの名前は、インデックスやループイテレータでよく使われている。汎用的な名前だけど、これだけで「ぼくはイテレータ」という意味になるので問題ない（それ以外の目的に使うとまぎらわしくなるのでやめよう！）
>> ループイテレータ：i, j, kなどはイテレータであることがすぐにわかるため、問題なく使えます（ただし、他の目的には使わないこと）。

< でも、i・j・kよりいい名前がある。例えば、クラブに所属しているユーザを調べるループを見てみよう。
>> しかし、i, j, kよりも良い名前はあります。クラブメンバーを調べるループの例を見てみましょう。

< for (int i = 0; i < clubs.size(); i++)
    for (int j = 0; j < clubs[i].members.size(); j++)
        for (int k = 0; k < users.size(); k++)
            if (clubs[i].members[k] == users[j])
                cout << "user[" << j << "] is in club[" << i << "]" << endl;
if文にあるmembers[]とusers[]のインデックスが逆になっている。そこだけ見ると問題がなさそうに見えるので、バグを見つけるのが難しい。
>> このコードはインデックスが逆になっており、一見問題なさそうに見えるためバグの発見が難しいです。

< if (clubs[i].members[k] == users[j])
イテレータが複数あるときには、インデックスにもっと明確な名前をつけるといいだろう。i・j・kではなく、説明的な名前（club_i・members_i・users_i）にするのだ。あるいは、もっと簡潔なもの（ci・mi・ui）でもいいだろう。こうすればバグが目立ちやすくなる。
>> 複数のイテレータがある場合、i, j, kではなく、club_i/ci, members_i/mi, users_i/uiのような明確な名前にするとバグが目立ちやすくなります。

< if (clubs[ci].members[ui] == users[mi])  # バグだ！最初の文字が違ってる。
インデックスの最初の文字は、配列の名前の最初の文字と同じになるのが正しい。
>> （省略：バグの例）

< if (clubs[ci].members[mi] == users[ui])  # OK。最初の文字が同じだ。
汎用的な名前のまとめ
>> （省略：修正後の例）

< これまで見てきたように、汎用的な名前が役に立つこともある。
>> 汎用的な名前のまとめ：汎用的な名前も役立つ場合があります。

< [Tip]
アドバイス
>> 【ヒント】アドバイス

< tmp・it・retvalのような汎用的な名前を使うときは、それ相応の理由を用意しよう。
>> tmp、it、retvalなどの汎用的な名前を使う場合は、明確な理由が必要です。

< ただし、単なる怠慢で使われていることも多い。いい名前が思いつかなかったら、fooのような意味のない名前を使いたくなってしまうものだ。だけど、少しでも時間を使っていい名前を考える習慣をつけるようにすれば、すぐに「命名力」の高まりが感じられるようになるだろう。
>> 良い名前が思いつかないからと安易に使うのではなく、時間をかけて良い名前を考える習慣をつけることで「命名力」が向上します。

< 2.3　抽象的な名前よりも具体的な名前を使う
>> 2.3 抽象的な名前よりも具体的な名前を使う

< 変数や関数などの構成要素の名前は、抽象的ではなく具体的なものにしよう。
>> 変数や関数の名前は、抽象的ではなく具体的なものにすべきです。

< 例えば、ServerCanStart()という名前のメソッドがあったとする。任意のTCP/IPポートをサーバがリッスンできるかを確認するメソッドである。でも、ServerCanStart()という名前はちょっと抽象的だ。具体的な名前にすれば、CanListenOnPort()になるだろう。これならメソッドの動作をそのまま表している。
>> 例えば、ServerCanStart()（サーバがポートをリッスンできるか確認するメソッド）は抽象的なので、動作をそのまま表すCanListenOnPort()のほうが具体的で優れています。

< 以下の2つの例は、この考えを詳しく示したものだ。
>> この考えを具体的に示す2つの例を紹介します。

< 例：DISALLOW_EVIL_CONSTRUCTORS
これはGoogle社から持ってきたコードだ。C++のクラスでは、コピーコンストラクタと代入演算子を再定義しないと、デフォルトの設定が使われてしまう。お手軽なのはいいけれど、デフォルトのメソッドだとメモリリークなどの問題につながる可能性がある。みんなが気づかない「舞台裏」で実行されてしまうからだ。
>> 例：DISALLOW_EVIL_CONSTRUCTORS（GoogleのC++コード）では、デフォルトのコピーコンストラクタと代入演算子がメモリリークなどの問題を引き起こす可能性があるため、これらを禁止するマクロが使われています。

< そのためGoogle社では、こうした「悪の」コンストラクタを許可しない規約を作り、マクロを使って対応している。
>> Googleでは、この「悪の」コンストラクタを許可しないためのマクロが使われていました。

< class ClassName {
  private:
    DISALLOW_EVIL_CONSTRUCTORS(ClassName);

  public:
    ...
};
このマクロは以下のように定義されている。
>> （省略：DISALLOW_EVIL_CONSTRUCTORSの使用例）

< #define DISALLOW_EVIL_CONSTRUCTORS(ClassName) \
    ClassName(const ClassName&); \
    void operator=(const ClassName&);
このマクロをクラスのprivate:に置くと、2つのメソッドがプライベートになる。こうすれば、間違ってメソッドを使うことはない。
>> このマクロは、コピーコンストラクタと代入演算子をprivateにし、誤用を防ぎます。

< でも、DISALLOW_EVIL_CONSTRUCTORSという名前があまりよくない。「EVIL（悪の）」という言葉には、必要以上に強い意志を感じてしまう。そんなことよりも、このマクロが「許可していないもの」を明確にするほうが大切だ。実際にはoperator=()メソッドも許可していない。このメソッドは「CONSTRUCTORS（コンストラクタ）」ではないのだ！
>> DISALLOW_EVIL_CONSTRUCTORSという名前は感情的で、マクロが禁止しているもの（特にコンストラクタではないoperator=()）を明確にしていません。

< 長年使用されてきた名前だったけど、最終的にはあまり刺激的ではなく、より具体的な名前に変更されることになった。
>> この名前は長年使われましたが、最終的により具体的で刺激的でない名前に変更されました。

< #define DISALLOW_COPY_AND_ASSIGN(ClassName) ...
例：--run_locally
>> 変更後の名前はDISALLOW_COPY_AND_ASSIGNになりました。

< ぼくたちのプログラムには、--run_locallyという名前のコマンドオプションがあった。このオプションをつけると、プログラムがデバッグ情報を印字するようになる。ただし、動作は遅くなってしまう。このオプションは、デスクトップなどのローカルマシンでテストをするときに使っていた。リモートサーバで動かすときにはパフォーマンスが重要になるので使わなかった。
>> 例：--run_locallyというコマンドオプションは、デバッグ情報出力（動作が遅くなる）を有効にするために、ローカルマシンでのテスト時のみ使われていました。

< --run_locallyの名前の由来はわかったと思う。でも、これには問題があった。
>> --run_locallyという名前の由来はわかりますが、問題がありました。

< まず、新しいチームメンバがこのオプションを理解できなかった。ローカルで動かすときには使っていたようだけど（名前から推測したのだろう）、どうしてこれが必要なのかはわかっていなかった。
>> 新しいメンバーは、なぜそのオプションが必要なのかを理解できませんでした。

< リモートで動かすときにデバッグ情報を印字したいこともある。そんなときは、リモートで動いているプログラムに--run_locallyオプションを渡す。リモートなのに「locally」ってなんだか変な感じだ。すごくまぎらわしい。
>> リモート実行時にデバッグ情報が欲しい場合、--run_locallyを使うと「locally」という名前が混乱を招きました。

< ローカルでパフォーマンステストをしたいこともある。そんなときは、動作の遅くなるロギング機能は使いたくない。だから、ローカルで動かすけど、--run_locallyは使わない。
>> パフォーマンステスト時には、ローカルでも速度が遅くなる--run_locallyを使いたくないケースがありました。

< --run_locallyに環境の名前が入っているのが問題なのだ。--extra_loggingという名前のほうが直接的で明確だ。
>> --run_locallyは環境名が含まれているのが問題で、--extra_loggingのように直接的で明確な名前にすべきです。

< でも、--run_locallyの機能がロギングだけじゃなかったらどうしよう？　例えば、ローカル用の特別なデータベースを設定して使う必要があったとしよう。それなら両方の機能を表現できている--run_locallyでもいいような気がしてくる。
>> --run_locallyの機能がロギングだけでなく、ローカルDB設定など複数あった場合でも、この名前が適切に両方を表現できているか疑問です。

< でも、名前と目的が合っていない。あいまいだし間接的だ。ここでは、--use_local_databaseのようなオプションを用意するといいだろう。オプションは2つに増えるけど、それぞれの意味は明確だ。直交する概念は無理に1つにまとめようとせずに、別々に使えるようにするといい。
>> --run_locallyは名前と目的が合っておらず曖昧です。--use_local_databaseのようにオプションを分けて、直交する概念を無理にまとめない方が明確です。

< 2.4　名前に情報を追加する
>> 2.4 名前に情報を追加する

< 前にも言ったけど、名前は短いコメントのようなものだ。変数名に詰め込める情報はあまり多くない。だけど、名前につけた情報は変数を見るたびに目に入ってくる。
>> 名前は短いコメントのようなもので、情報量は少ないですが、変数を見るたびにその情報が目に入ってきます。

< だから、もし絶対に知らせなきゃいけない大切な情報があれば、「単語」を変数名に追加すればいい。例えば、16進数の文字列を持つ変数について考えてみよう。
>> 重要な情報がある場合は、その「単語」を変数名に追加すべきです。例えば、16進数の文字列を持つ変数の例です。

< string id;  // 例： "af84ef845cd8"
IDのフォーマットが大切なら、名前をhex_idにするといい。
>> IDのフォーマットが重要なら、名前をhex_idにすると良いでしょう。

< 値の単位
時間やバイト数のように計測できるものであれば、変数名に単位を入れるといいだろう。
>> 値の単位：時間やバイト数など測定可能な値の場合、変数名に単位を入れるべきです。

< 例えば、ウェブページの読み込み時間を計測するJavaScriptのコードを見てみよう。
>> 例として、ウェブページの読み込み時間を計測するJavaScriptコードを見ます。

< var start = (new Date()).getTime();  // ページの上部
...
var elapsed = (new Date()).getTime() - start;  // ページの下部
document.writeln("読み込み時間：" + elapsed + " 秒");
このコードは間違っていないように見える。でも、これではうまく動かない。getTime()が秒ではなく、ミリ秒を返すからだ。
>> このコードは間違っているように見えませんが、getTime()がミリ秒を返すため正しく動作しません。

< 変数名に_msを追加すれば明確になる。
>> 変数名に_msを追加すると明確になります。

< var start_ms = (new Date()).getTime();  // ページの上部
...
var elapsed_ms = (new Date()).getTime() - start_ms;  // ページの下部
document.writeln("読み込み時間：" + elapsed_ms / 1000 + " 秒");
時間以外にもプログラミングで使う単位はたくさんある。以下の表は、単位のない仮引数と、単位を追加したよりよいバージョンの仮引数を示したものだ。
>> （省略：修正後のコード）プログラミングでは他にも多くの単位があります。単位を追加した仮引数の例は以下の通りです。

< 関数の仮引数	単位を追加した仮引数
Start(int delay)	delay→delay_secs
CreateCache(int size)	size→size_mb
ThrottleDownload(float limit)	limit→max_kbps
Rotate(float angle)	angle→degrees_cw
>> （省略：単位追加の表）

< その他の重要な属性を追加する
変数名に追加する情報は単位だけではない。危険や注意を喚起する情報も追加したほうがいい。
>> その他の重要な属性を追加する：変数名に追加する情報には、単位だけでなく、危険や注意を喚起する情報も含まれるべきです。

< 例えば、セキュリティ問題の多くは、プログラムの受信するデータが安全ではないことが原因で発生している。このようなデータには、untrustedUrlやunsafeMessageBodyなどの変数名を使うといいだろう。データを安全にする関数を呼び出したあとは、変数名をtrustedUrlやsafeMessageBodyにするといい。
>> セキュリティ問題を防ぐため、安全でないデータにはuntrustedUrlなどを、安全処理後はtrustedUrlなどを使うと良いでしょう。

< 以下の表は、情報を変数名に追加したほうがいい例を示している。
>> 情報を変数名に追加した方が良い例を以下の表に示します。

< 状況	変数名	改善後
passwordはプレインテキストなので、処理をする前に暗号化すべきである。	password	plaintext_password
ユーザが入力したcommentは表示する前にエスケープする必要がある。	comment	unescaped_comment
htmlの文字コードをUTF-8に変えた。	html	html_utf8
入力されたdataをURLエンコードした。	data	data_urlenc
>> （省略：変数名改善の表）

< すべての変数名にunescaped_や_utf8などの属性を追加しろということではない。変数の意味を間違えてしまったときにバグになりそうなところにだけ使うことが大切だ。特にセキュリティのバグのような深刻な被害が出るところに使うといいだろう。基本的には、変数の意味を理解してもらわなければ困るところに属性を追加しておこう。
>> すべての変数に属性を追加するのではなく、特にセキュリティに関わる深刻なバグの原因になりやすいなど、変数の意味を誤解すると困る場合に属性を追加することが重要です。

< これってハンガリアン記法なの？
ハンガリアン記法というのは、Microsoft社で広く使われていた命名規則だ。すべての変数名の接頭辞に「型」をつける。例えば、こんな感じだ。
>> ハンガリアン記法とは、Microsoftで広く使われた命名規則で、変数名の接頭辞に「型」をつけます。

< 変数名	意味
pLast	あるデータ構造の最後の要素を指すポインタ（p）
pszBuffer	ゼロ終端（z）の文字列（s）バッファを指すポインタ（p）
cch	文字（ch）のカウント（c）
mpcopx	カラーのポインタ（pco）からX軸のポインタ（px）を指すマップ（m）
>> （省略：ハンガリアン記法の例）

< これも「名前に属性を追加」しているけれど、もっと厳密で規律のあるシステムだ。
>> これも属性を追加していますが、より厳格で規律に基づいたシステムです。

< 一方、本節でぼくたちが提唱しているのは、もっと大まかで規律の緩いシステムだ。必要なときにだけ変数の大切な属性を見つけ出して、それを読みやすくして名前に追加する。これをハンガリアンならぬ「イングリッシュ記法」と呼んでもいいだろう。
>> 本節で提唱しているのは、必要に応じて変数の重要な属性を名前に追加する、より緩やかなシステムで、「イングリッシュ記法」と呼べます。

< 2.5　名前の長さを決める
>> 2.5 名前の長さを決める

< いい名前を選ぶときには、「長い名前を避ける」という暗黙的な制約がある。以下のような識別子は、誰もが嫌がるだろう。
>> 良い名前を選ぶには「長い名前を避ける」という制約があり、例えば以下のような識別子は避けたいものです。

< newNavigationControllerWrappingViewControllerForDataSourceOfClass
長い名前は覚えにくいし、画面を大きく占領してしまう。折り返しが必要になれば、コード行が無駄に増えてしまう。
>> 長い名前は覚えるのが大変で、画面を占領し、コード行を無駄に増やします。

< だけど、「長い名前を避ける」を真に受けてしまったら、1つの単語（あるいは1文字）だけの名前になってしまう。それじゃあ、どのあたりに線を引けばいいのだろう？　d・days・days_since_last_updateのなかから1つを選ぶにはどうすればいいだろう？
>> しかし、短すぎると1文字の名前になってしまいます。d、days、days_since_last_updateのどれを選ぶべきでしょうか？

< それは、変数の使い方によって違ってくる。でも、ガイドラインはある。
>> それは変数の使い方によりますが、ガイドラインは存在します。

< スコープが小さければ短い名前でもいい
長期休暇よりも短期でどこかへ行くときのほうが荷物は少ないはずだ。それと同じで、識別子の「スコープ」（その名前が「見える」コードの行数）が小さければ、多くの情報を詰め込む必要はない。すべての情報（変数の型・初期値・破棄方法など）が見えるので、変数の名前は短くていい。
>> スコープが小さければ短い名前で良い：名前が「見える」範囲（スコープ）が小さい場合、変数の情報が近くにあるため、名前は短くても構いません。

< if (debug) {
    map<string,int> m;
    LookUpNamesNumbers(&m);
    Print(m);
}
mという変数名にはあまり情報が含まれていない。でも、大丈夫。コードを理解するのに必要な情報がすぐそばにあるからだ。
>> この例ではmに情報が少なくても、必要な情報がすぐ近くにあるため問題ありません。

< mがクラスのメンバ変数やグローバル変数ならどうだろう。以下のようなコードを目にするかもしれない。
>> mがメンバ変数やグローバル変数だとどうなるでしょうか。以下のようなコードかもしれません。

< LookUpNamesNumbers(&m);
Print(m);
このコードは読みにくい。mの型や目的がよくわからないからだ。
>> このコードはmの型や目的がわからず、読みにくいです。

< 識別子のスコープが大きければ、名前に十分な情報を詰め込んで明確にする必要がある。
>> 識別子のスコープが大きい場合は、名前に十分な情報を盛り込んで明確にする必要があります。

< 長い名前を入力するのは問題じゃない
長い名前を避ける理由はいくつもある。でも、「入力しにくい」というのは、もはや理由にならない。プログラミングに使うテキストエディタには「単語補完」機能がついている。この機能を知らないプログラマは意外と多い。まだ使ったことがないなら、本書をひとまず横に置いて、すぐに試してみて欲しい。
>> 長い名前を入力するのは問題じゃない：長い名前を避ける理由に「入力しにくい」は当てはまりません。ほとんどのエディタには単語補完機能があるからです。

< 名前の最初の1文字を入力する。
単語補完のコマンドを実行する（以下参照）。
補完された単語が正しくなければ、正しい名前が出現するまでコマンドを実行し続ける。
これがビックリするほど正確なんだ。どんなファイル形式でも、どんな言語でもうまくいく。それにどんなトークンにも使える。コメントを入力しているときでも大丈夫だ。
>> （省略：単語補完の具体的な手順）単語補完機能は非常に正確で、コメントを含むあらゆるトークンに使えます。

< エディタ	コマンド
Vi	Ctrl-p
Emacs	Meta-/（ESCを押してから/）
Eclipse	Alt-/
IntelliJ IDEA	Alt-/
TextMate	ESC
頭文字と省略形
>> （省略：単語補完のコマンド表）

< プログラマは頭文字や省略形を使って名前を短くすることがある。例えば、クラス名をBackEndManagerじゃなくてBEManagerにしたりする。このように情報を圧縮すると混乱の元になるだろうか？
>> 頭文字と省略形：プログラマは省略形を使いますが（例：BEManager）、これが混乱の原因にならないでしょうか？

< ぼくたちの経験からすると、プロジェクト固有の省略形はダメだ。新しくプロジェクトに参加した人は、暗号みたいに見えて怖いと思うだろう。しばらくすると、それを書いた人ですら暗号みたいで怖いと思うようになる。
>> プロジェクト固有の省略形は避けるべきです。新しい参加者にとっては暗号のようで、書いた本人も後で混乱します。

< 新しいチームメイトはその名前の意味を理解できるだろうか？　理解できるなら問題ない。
>> 新しいチームメンバーがその名前の意味を理解できるなら問題ありません。

< プログラマは、evaluationの代わりにevalを使う。documentの代わりにdocを使う。stringの代わりにstrを使う。だから、新しいチームメイトもFormatStr()の意味は理解できる。でも、BEManagerの意味は理解できない。
>> eval (evaluation) や str (string) など、一般的に使われる省略形は理解されますが、BEManagerのような固有の省略形は理解されません。

< 不要な単語を投げ捨てる
名前に含まれる単語を削除しても情報が全く損なわれないこともある。例えば、ConvertToString()を短くしてToString()にしても、必要な情報は何も損なわれていない。同様に、DoServeLoop()をServeLoop()に変えても明確さは同じだ。
>> 不要な単語を削除する：ConvertToString()をToString()に、DoServeLoop()をServeLoop()にするなど、情報を損なわずに短縮できる単語は削除しましょう。

< 2.6　名前のフォーマットで情報を伝える
>> 2.6 名前のフォーマットで情報を伝える

< アンダースコア・ダッシュ・大文字を使って、名前に情報を詰め込むこともできる。例えば、Google社のオープンソースプロジェクトで使っているC++のフォーマット規約を見てみよう。
>> アンダースコア、ハイフン、大文字などのフォーマット要素を使って、名前に情報を追加できます。GoogleのC++フォーマット規約を例に挙げます。

< static const int kMaxOpenFiles = 100;

class LogReader {
  public:
    void OpenFile(string local_file);

  private:
    int offset_;
    DISALLOW_COPY_AND_ASSIGN(LogReader);
};
エンティティごとに異なるフォーマットを使っている。一種のシンタックスハイライトと言えるかもしれない。これでコードが読みやすくなっている。
>> この規約ではエンティティごとに異なるフォーマットが使われ、一種のシンタックスハイライトとしてコードの読みやすさを高めています。

< このフォーマットはよく使われているものだ。クラス名はCamelCase（キャメルケース）で、変数名はlower_separated（小文字をアンダースコアで区切ったもの）。でも、その他の規約にはビックリするかもしれない。
>> クラス名はCamelCase、変数名はlower_separatedが一般的ですが、その他の規約には驚くかもしれません。

< 例えば、定数はCONSTANT_NAMEではなくkConstantNameになっている。MACRO_NAMEのような#defineマクロと簡単に区別できるからだ。
>> 定数はCONSTANT_NAMEではなくkConstantNameとなっており、#defineマクロと区別しやすくなっています。

< クラスのメンバ変数は、一見普通の変数のように見えるけど、offset_のように最後の文字がアンダースコアになっている。ぼくたちも最初は奇妙に思ったけど、普通の変数と区別できるので便利だ。例えば、長いメソッドを読んでいると、以下のようなコードが目に入ってくる。
>> クラスのメンバ変数はoffset_のように末尾にアンダースコアがつき、通常の変数と区別できて便利です。

< stats.clear();
普通なら「statsはクラスのメンバ変数かな？　これはクラスの内部状態を変えるコードなんだろうか？」などと考えるだろう。メンバ変数をmember_にする規約を守っていれば、「メンバ変数じゃない。このstatsはローカル変数だ」とすぐにわかる。クラスのメンバ変数ならstats_になるからだ。
>> （省略：メンバ変数とローカル変数の区別の例）この規約により、statsがローカル変数かメンバ変数かがすぐに判別できます。

< その他のフォーマット規約
プロジェクトや言語によって使えるフォーマット規約は違ってくる。なかにはより多くの情報を詰め込める規約もある。
>> その他のフォーマット規約：プロジェクトや言語に応じて、さらに多くの情報を伝えられるフォーマット規約があります。

< 例えば、『JavaScript: The Good Parts』（Douglas Crockford, O'Reilly, 2008）†1では、「コンストラクタ」（newを使って呼び出される関数）は大文字で始め、通常の関数は小文字で始めるように著者が提唱している。
>> JavaScriptでは、「コンストラクタ」関数を大文字で始め、通常の関数を小文字で始めることが提唱されています。

< var x = new DatePicker();  // DatePicker()は「コンストラクタ」関数
var y = pageHeight();      // pageHeight()は通常の関数
その他にもJavaScriptでは、jQueryのライブラリ関数（$だけの関数）を呼び出したときには、変数名の頭に$をつけるというものがある。
>> （省略：コンストラクタと通常関数の例）またJavaScriptでは、jQueryオブジェクトを変数名の頭に$をつけて区別することがあります。

< var $all_images = $("img");  // $all_imagesはjQueryのオブジェクト
var height = 250;            // heightは違う
こうすれば、$all_imagesがjQueryのオブジェクトだと明確にわかる。
>> これにより、$all_imagesがjQueryオブジェクトであることが明確になります。

< 最後にHTMLとCSSの例を紹介しよう。HTMLタグのidやclassなどの属性名には、アンダースコアやハイフンも妥当な文字として使うことができる。ただし、idの区切り文字にはアンダースコアを、classの区切り文字にはハイフンを使う規約が有力だ。
>> HTML/CSSでは、idの区切り文字にアンダースコア、classの区切り文字にハイフンを使う規約が有力です。

< <div id="middle_column" class="main-content"> ...
以上のような規約を使うかどうかは、自分自身やチームで決めるといい。どんなものを使うにしても、プロジェクトで一貫性を持たせることが大切だ。
>> （省略：HTML/CSSの例）これらの規約を採用するかどうかはチームで決めるべきですが、プロジェクト全体で一貫性を持たせることが重要です。

< 2.7　まとめ
本章のテーマは「名前に情報を詰め込む」だった。つまり、名前を見ただけで情報を読み取れるようにすることだ。
>> 2.7 まとめ：本章のテーマは「名前に情報を詰め込む」で、名前だけで情報を読み取れるようにすることでした。

< 以下は、ぼくたちが説明したヒントだ。
>> 説明したヒントを以下に示します。

< 明確な単語を選ぶ。——例えば、Getではなく、状況に応じてFetchやDownloadなどを使う。
>> 明確な単語を選びましょう（例：Getの代わりにFetchやDownloadを使う）。

< tmpやretvalなどの汎用的な名前を避ける。——ただし、明確な理由があれば話は別だ。
>> tmpやretvalなどの汎用的な名前は避けましょう（ただし、明確な理由があれば使用可）。

< 具体的な名前を使って、物事を詳細に説明する。——ServerCanStart()よりもCanListenOnPort()のほうが明確だ。
>> 具体的な名前で詳細を説明しましょう（例：CanListenOnPort()はServerCanStart()より明確）。

< 変数名に大切な情報を追加する。——ミリ秒を表す変数名には、後ろに_msをつける。これからエスケープが必要な変数名には、前にraw_をつける。
>> 変数名に重要な情報を追加しましょう（例：ミリ秒に_ms、エスケープ前のデータにraw_をつける）。

< スコープの大きな変数には長い名前をつける。——スコープが数画面に及ぶ変数に1〜2文字の短い暗号めいた名前をつけてはいけない。短い名前はスコープが数行の変数につけるべきだ。
>> スコープの大きい変数には長い名前をつけ、短い名前はスコープが短い変数に限定しましょう。

< 大文字やアンダースコアなどに意味を含める。——例えば、クラスのメンバ変数にアンダースコアをつけて、ローカル変数と区別する。
>> 大文字やアンダースコアなどで意味を伝えましょう（例：メンバ変数にアンダースコアをつけローカル変数と区別する）。